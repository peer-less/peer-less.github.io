<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="个人博客，记录成长的点滴。">
  <meta name="author" content="peerless">
  <meta name="keywords" content="">
  <title>2015-ICFCA-Exploring Faulty Data - peerless</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>peerless</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-12-28 09:43">
      2020年12月28日 上午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      70
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="Exploring-Faulty-Data"><a href="#Exploring-Faulty-Data" class="headerlink" title="Exploring Faulty Data"></a>Exploring Faulty Data</h1><div class="note note-primary">
            <p>属性探索、容错、置信度</p>
          </div> 
<a id="more"></a>
<!-- <p class='note note-info'>论文、属性探索</p> -->
<h2 id="论文基本信息"><a href="#论文基本信息" class="headerlink" title="论文基本信息"></a>论文基本信息</h2><pre><code>              1. 作者：Daniel Borchmann。
             2. 会议：ICFCA 。
             3. 时间：2015。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
</code></pre><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ol>
<li>属性探索是半自动检查给定域数据完备性的强大工具。</li>
<li>然而，经典属性探索没有考虑到初始数据中可能存在的错误。</li>
<li>为了纠正这一点，我们提出基于置信度的属性探索，它将允许探索在初始数据中不一定成立但却享有最低置信度的蕴涵式。</li>
</ol>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>1.属性探索是形式概念分析领域中最重要的算法之一[9]。</p>
<p>该算法的主要目的是检查给定的初始数据集的完备性，从这个意义上说，该算法帮助领域专家检查该初始数据是否完全代表该专家感兴趣的特定领域。</p>
<p>在这样做的过程中，算法向专家展示了蕴涵式，专家要么必须认为蕴涵式成立，要么必须提供一个来自该领域的反例。当算法完成后，初始数据被扩展为一组完备的示例，这些示例成立的蕴涵式恰好是域中有效的所有蕴涵式。</p>
<p>但是，因为所有数据实际上都来自域，所以这种方法要求初始数据没有错误。在实际应用中，这可能是不合理的假设，因为检查数据的正确性也可能是不合理的。</p>
<p>2.认为数据集是“高质量”的是说，错误“很少”发生。为了处理这样的场景，提出了一种基于置信度的数据挖掘方法[1]。</p>
<p>此外，通过置信度进行探索必须被视为完成过程的第一步，由此产生的一组蕴涵式和一组对象应该可以进一步使用。例如，从置信度探索中获得的蕴涵式可以用作从空数据集开始的经典属性探索的背景知识。</p>
<p>3.这并不是置信度探索的第一个工作。</p>
<ol>
<li>Luxenburger[10]，他在形式背景中考虑了的蕴涵式的支持度和置信度。然而，但他并没有考虑属性探索。</li>
<li>另一方面，也有一些关于属性探索更适合于实际应用的研究。这里值得注意的工作是Burmeister和Holzer的不完全知识探索[5]，以及Stumme的背景蕴涵和异常的属性探索[11]。</li>
</ol>
<p>主要贡献：一种基于置信度的探索算法，将在第5节中讨论。</p>
<p>该算法是属性探索的通用公式的一个实例，将在第4节中介绍。天真而直接地应用这一广义算法将产生第一个版本的置信度探索，然而，从某种意义上说，这只是“近似的”，这将在5.1节中讨论。对第5.2节中给出的这个近似版本稍作修改，就可以得到所需的可信度勘探算法。</p>
<p>这项工作的结果取自[4]，它不仅包含了本文中的证明(由于篇幅限制，我们省略了它)，而且还适应了置信度探索，它也适用于一般概念包含，即类似于描述逻辑领域中使用的蕴涵的逻辑对象。我们将在第6节对这一改编结果作一个非常简要的展望。</p>
<h2 id="2-Implications-and-Confidence"><a href="#2-Implications-and-Confidence" class="headerlink" title="2 Implications and Confidence"></a>2 Implications and Confidence</h2><p>$ Imp(M) $：集合M上所有蕴涵的集合。</p>
<p>$ A \rightarrow B \in Imp(M)$成立 $\Leftrightarrow$ $ A^{\prime} \subseteq B^{\prime} $</p>
<p>$ Th(\mathbb{K}) $：在M上所有在$\mathbb{K} = (G, M,I)$中有效的有效蕴涵的集合。</p>
<p>$ L\subseteq Imp(M)，（A\rightarrow B)\in Imp(M)$</p>
<p>在属性集合M的所有形式背景$\mathbb{L}$中，如果来自$L$的所有蕴涵在$\mathbb{L}$中成立，则$(A→B)$在$\mathbb{L}$中也成立。</p>
<p>$\mathbb{L} \models L \Rightarrow \mathbb{L} \models (A\rightarrow B)$</p>
<p>$\mathbb{L} \models L$：表示L中的所有蕴涵在$\mathbb{L}$中都成立。</p>
<p>$Cn_{M}(L)$：L $ \subseteq Imp(M)$, 如果显然来自于集合M，我们将删除下标。</p>
<p>蕴涵式之间的蕴涵可以用不同的方式来描述。为此，我们引入了蕴涵集诱导的闭包算子的概念。更准确地说，我们为$A\subseteq M$定义了运算符</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228111526787.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228111526787.png" srcset="/img/loading.gif" alt></p>
<p>$A\mapsto L(A)$：由L诱导的闭包算子。</p>
<p>当且仅当$A=L(A)$时，称集合A为在L下闭集。</p>
<p>由$L$诱导的闭包运算符现在可以用来形式化蕴涵式间的蕴涵关系：$\mathbb{L} \models L (A\rightarrow B) \Leftrightarrow B\subseteq L(A)$</p>
<p>$K\subseteq Imp(M)$：另一组蕴涵集。</p>
<p>$L$为$K$的基当且仅当$Cn(L)=Cn(K)$，$K$中的所有蕴涵都由$L$蕴涵，反之亦然。</p>
<p>如果$K = Th({\mathbb{K}})$，则我们称L为$\mathbb{K}$的基。</p>
<p>非冗余且最小：如果$L$是$K$的基，那么如果没有$L$的真子集也是$K$的基，则$L$称为非冗余的。此外，当且仅当不存在满足$|L^{\prime}|&lt;|L|$的$K$的另一个基$L^{\prime}$时，称$L$为极小的。</p>
<p>如果我们搜索$K$的蕴涵基，情况可能是不想包含我们已经“知道”的某一组蕴涵$L_{back}$（背景知识）。则蕴涵基为$K \backslash Cn(L_{back})$</p>
<p>因此，只有当$L\cup L_{back}$是$K$的基时，我们才称集合$L\subseteq Imp(M)$是K相对于$L_{back}$的基(或具有背景知识的K的基)。</p>
<p>已知具有最小基数的特定相对基是标准基$Can(K，L_{back})$。为了定义这个基，我们需要引入[11]的$L_{back}$伪闭集的概念。</p>
<p>$L_{back}$伪闭集:</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228114818061.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228114818061.png" srcset="/img/loading.gif" alt></p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228115001588.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228115001588.png" srcset="/img/loading.gif" alt></p>
<p>设$\mathbb{K}=(G，M，I)$为形式背景，$(A\rightarrow B)\in Imp(M)$。</p>
<p>$(A\rightarrow B)$的一个反例是对象$g\in A^{\prime}\backslash B^{\prime}$，显然，$A\rightarrow B$在$\mathbb{K}$中成立的充要条件是$\mathbb{K}$不包含$A\rightarrow B$的反例。相反，我们称g为$A\rightarrow B$的模型(正例)当且仅当$g\notin A^{\prime}$ 或 $g\in B^{\prime}$。</p>
<p>与反例的概念相关，我们将$A\rightarrow B$对$\mathbb{K}$的置信度定义为</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228152621497.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228152621497.png" srcset="/img/loading.gif" alt></p>
<p>$c\in [0,1]$</p>
<p>$Th_{c}(\mathbb{K})$：表示$Imp(M)$中置信度至少为$c$的所有蕴涵的集合。</p>
<p>然而，集合$Th_{c}(\mathbb{K})$不是在蕴涵下闭合的，因此$L\subseteq Th_{c}(\mathbb{K})$不一定是真的。</p>
<p>然而，如果$Th_{c}(\mathbb{K})$的基的元素也是“几乎有效的”，即对置信度至少为c的$\mathbb{K}$成立，则$Th_{c}(\mathbb{K})$的基可能更有用。因此，当且仅当$L$是$Th_{c}(\mathbb{K})$的基和$L\subseteq Th_{c}(\mathbb{K})$的基时，我们才称$L$为<script type="math/tex">Th_{c}(\mathbb{K})</script>的可信基(或者仅称$\mathbb{K}$，如果c从上下文中看得很清楚)。</p>
<h2 id="3-Classical-Attribute-Exploration"><a href="#3-Classical-Attribute-Exploration" class="headerlink" title="3 Classical Attribute Exploration"></a>3 Classical Attribute Exploration</h2><p>这一部分的目的是介绍属性探索，因为这是本文论述所需要的。这包括对经典属性探索算法的描述，我们现在将给出这一描述。然后，我们将在第4节讨论一种广义的属性探索形式，它使用与[3]中给出的思想相似但不同的思想。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228170216938.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228170216938.png" srcset="/img/loading.gif" alt></p>
<p>Definition 1. 关于M的领域专家是一个函数</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228170556172.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/images/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228170527878.png" srcset="/img/loading.gif" alt><br><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228170556172.png" srcset="/img/loading.gif" alt></p>
<p>$Th(p)$：专家p认为成立的所有蕴涵的集合。</p>
<p>很容易看出，每个领域都会产生一个领域专家。</p>
<p>Lemma 1. 设D是集合M上的一个域(形式背景)，对于D中存在反例的每个$(A\rightarrow B)\in Imp(M)$，设$C_{A\rightarrow B}$为这样的反例。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228172857897.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/images/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228172857897-1609148169012.png" srcset="/img/loading.gif" alt></p>
<p>请注意，$pD$的定义取决于反例的特定选择，因此D可能会产生多个领域专家。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228173054625.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228173054625.png" srcset="/img/loading.gif" alt></p>
<p>Lemma 2. 设M是一个集合，p是M上的领域专家，则对每个$(A\rightarrow B)\in Imp(M)$成立。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228173538465.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228173538465.png" srcset="/img/loading.gif" alt></p>
<p>现在我们已经正式地理解了专家的概念，我们准备以一种正式的方式描述属性探索的算法，如算法1所示。在本文中，我们假设集合M有一个严格的线性序，这就产生了一个选择序，因为它是应用下一个闭包算法所需要的[8]。此外，为了更好的可读性，我们通过由$\mathbb{K}$+C添加一个具有来自C的属性的新对象来表示从另一个形式背景$\mathbb{K}$产生的形式背景。</p>
<p>请注意，可以使用NEXT闭包算法从$P_{i}, K_i, L_i$计算集合$P_{i+1}$。由于细节与我们的进一步讨论无关，我们建议感兴趣的读者参考文献[4]。</p>
<p>下面的结果是算法1的众所周知的性质，相应的证明可以在[6，7，9，11]中找到。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228174053017.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228174053017.png" srcset="/img/loading.gif" alt></p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228174234207.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201228174234207.png" srcset="/img/loading.gif" alt></p>
<h2 id="4-Exploring-Sets-of-Implications"><a href="#4-Exploring-Sets-of-Implications" class="headerlink" title="4 Exploring Sets of Implications"></a>4 Exploring Sets of Implications</h2><p>在上一节中，我们得到了属性探索的精确公式。然而，这一提法并不适用于我们以某种最低的置信度探索含义的设置。为了解决这个问题，我们将在这一部分开发一个超越经典的属性探索的更一般的公式。</p>
<p>我们想尝试将这种属性探索的描述提升到置信探索的情况下。在那里，我们的设置有点复杂。在经典属性探索的情况下，我们被给予一个领域专家$p$、一个形式背景$\mathbb{K}$和一组蕴涵$K$。此外，我们被给予$c\in [0，1]$，这是我们探索的置信度阈值。</p>
<p>然后，与经典设置相比，置信度探索不仅考虑了$Th(\mathbb{K})\backslash Cn(K)$中的蕴涵，还考虑了$Th_c(\mathbb{K})\backslash Cn(K)$中的蕴涵。我们假设$K$是一组至少具有置信度$c$的蕴涵，并且$K$中的所有蕴涵都由$p$确认；换句话说，$K\in Th(P)\ and\ K\in Th_c(\mathbb{K})$。虽然第一个条件相当明确，但第二个条件并不是严格必要的，只是为了简单起见而采用。</p>
<p>然后在这种情况下工作的属性探索算法应该引导专家通过$Th_c(\mathbb{K})\backslash Cn(K)$中的蕴涵，询问某些蕴涵是否正确。然后，专家提供的反例被用来说明$Th_c(\mathbb{K})$中的某些蕴涵不成立。然而，它们不用于计算置信度；这仅在初始上下文$\mathbb{K}$中完成，因为我们想要找到$Th_c(\mathbb{K})$的基。最后，属性探索算法应该同时计算蕴涵集合$L$和形式背景$\mathbb{L}$，使得$Th_c(\mathbb{K})$中的每个蕴涵要么在$\mathbb{L}$中无效，要么从$L\cup K$得到。</p>
<p>我们现在要描述的是一种更一般的属性探索公式，它适用于我们通过置信度进行探索的设置。为此，我们将在本节的剩余部分开发属性探索的一般公式，它与一组特定的含义和一组有趣的含义一起工作，并提供一种方法来指导专家通过一组未确定的含义，直到没有更多的含义。只要有可能，此算法应具有的属性应与经典情况下相同。然后，稍后，我们将把这个算法应用到我们的置信度设置中。</p>
<p>为此，让我们概括一下我们对探索算法的设置，这一次稍微更一般一些：我们给予一个有限集合M，一个关于M的领域专家p，以及两个蕴涵集合K，L。</p>
<p>在我们的经典情况下，对于某些形式背景$\mathbb{K}$，$L=Th(\mathbb{K})$；</p>
<p>在我们的置信度探索的设置中，同样对于一些形式背景$\mathbb{K}$和一些$c\in [0，1]$，我们将有$L=Th_c(\mathbb{K})$。我们假设$K\in Th(P)\ and\ K\in L$，则认为集合K是具有一定蕴涵的(初始)集合。在我们的探索过程中，我们只考虑L中的蕴涵，因此我们称这个集合为有趣的蕴涵集合。最后，对于$L\backslash Cn(K)$中的每一个蕴涵，还不清楚p是否确认它。因此，我们称这个集合为(当前)未决定含义的集合。</p>
<p>现在对该抽象设置的探索应该通过与专家p交互来计算具有背景知识K的$L\cap Th(P)$的相对基数。在最好的情况下，该交互被保持在最小(即，调用专家的次数尽可能少)，因为专家交互被认为是昂贵的。</p>
<p>考虑到经典的属性探索算法，提出一种合理适用于这一一般设置的重构式并不是很困难。为此，让我们确定一个有限集M和一个字典序$\preceq$在P(M)上。然后在算法2中给出这样的重新表述。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229110300937.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229110300937.png" srcset="/img/loading.gif" alt></p>
<p>这个算法存在的问题是，它不能确保询问专家的蕴涵是$L_i$的元素，$L_i$是当前所有有趣蕴涵的集合。因此，我们不能期望该算法实际计算$L\cap Th(P)$的相对基。然而，该算法所实现的是计算$L\cap Th(P)$的相对基的“近似”，即如果n是该算法最后一次迭代的索引，则该算法所做的不是计算$Cn(Th(P)\cap L)$的相对基$K_n$，而是它的一个完全超集。然而，这个集合对于$Cn(Th(P)\cap L)$来说并不太远，因为$Cn(K_n)\subseteq Th(P)\cap Cn(L)$。另一方面，$K_n$要尽可能小，以保证其自身的完好性和完整性。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229110119690.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229110119690.png" srcset="/img/loading.gif" alt></p>
<p>由于篇幅限制，我们不会证明以下结果，而是请感兴趣的读者参阅[4]。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229110620320.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229110620320.png" srcset="/img/loading.gif" alt></p>
<p>由于我们无法控制算法2所问的蕴涵是否在有趣蕴涵的集合L中，因此我们不能期望用$L=Th_c(\mathbb{K})$来实例化该算法确实会产生一个用于置信度探索的算法。因此，我们将讨论属性探索的另一种更一般化的版本，它将允许向专家询问含义的更大自由度。这一推广源于算法2，它观察到，与询问形式$P_{i+1}\rightarrow L_i(P_{i+1})$的蕴涵不同，仅询问形式$P_{i+1}\rightarrow Q_{i+1}$的蕴涵就足以证明算法的正确性，其中，形式$P_{i+1} \subsetneq Q_{i+1} \subseteq L_i(P_{i+1}), Q_{i+1}\nsubseteq K_i(P_{i+1})$。</p>
<p>将这一思想应用于算法2得到了算法3。后一种算法保留了前者的所有属性，只是它不一定再计算极小基。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229112619483.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229112619483.png" srcset="/img/loading.gif" alt></p>
<p>然而，正如我们将在第5.2节中看到的那样，通过适当地选择集合$Q_{i+1}$，我们可以使用算法3来设计用于置信度探索的算法。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229112759419.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229112759419.png" srcset="/img/loading.gif" alt></p>
<h2 id="5-Exploration-by-Confidence"><a href="#5-Exploration-by-Confidence" class="headerlink" title="5 Exploration by Confidence"></a>5 Exploration by Confidence</h2><p>基于我们在上一节中讨论的概括，我们现在将注意力转向我们的原始问题，即设计一种基于置信度的探索算法。回想一下，对于这一点，我们被给予有限集合M、具有属性集合M的形式背景$\mathbb{K}$、关于M的专家p、一些背景知识$K\subseteq Th(P)$和一些数c∈[0，1]。现在用于置信度探索的算法应该实现的是利用背景知识K计算$Th(P)\cap Th_c(\mathbb{K})$的基。理想情况下，为此，它应该尽可能少地调用专家p。</p>
<p>我们将在这一节开始介绍第一个算法，该算法不完全是用于按置信度进行探索的算法，而是上一节所讨论的意义上的近似算法。第一个算法将通过实例化第4节中的通用属性探索算法来获得。我们将在第5.1节中这样做。然后，我们将在5.2节中讨论基于置信度的探索的适当算法，在那里我们将实例化第4节中较弱的属性探索泛化。</p>
<h3 id="5-1-An-Approximative-Exploration-by-Confidence"><a href="#5-1-An-Approximative-Exploration-by-Confidence" class="headerlink" title="5.1 An Approximative Exploration by Confidence"></a>5.1 An Approximative Exploration by Confidence</h3><p>我们的第一个想法非常简单：我们使用算法2，并使用我们的置信度探索设置实例化它，即，我们设置$L=TH_C(\mathbb{K})$。得到的算法如算法4所示。定理2中给出的算法2的性质立即产生以下结果。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229113456689.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229113456689.png" srcset="/img/loading.gif" alt></p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229113627060.png" srcset="/img/loading.gif" class>
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229113627060.png" srcset="/img/loading.gif" alt></p>
<p>显然，算法4不保证所询问的含义实际上是$L=TH_C(\mathbb{K})$的元素，即，这些含义不需要在$\mathbb{K}$中具有至少c的置信度。这可能是问题，也可能不是问题，这取决于当前处理的应用。</p>
<p>算法4实用的另一个重要原因是能够在$L_i(A)=TH_c(\mathbb{K}) \cap TH(\mathbb{L}_i)$下计算闭包。然而，到目前为止，如何在这些含义下计算闭包是显而易见的。当然，人们不想显式地计算这些集合，事实上，对于每个A⊆M，         </p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229114234584.png" srcset="/img/loading.gif" class>          
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229114234584.png" srcset="/img/loading.gif" alt></p>
<p>因此，要使算法4实用，只需要一种方法来计算集合A在$TH_c(\mathbb{K})$下的闭包。 </p>
<p>虽然可以在不显式计算集合THC(K)的情况下有效地计算这些闭包[4]，但是计算开销可能是不受欢迎的。人们可能会认为，我们可以通过使用以下方法消除$TH_c(\mathbb{K})$下计算闭包的问题：而不是询问形式的蕴涵</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229114606755.png" srcset="/img/loading.gif" class>          
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229114606755.png" srcset="/img/loading.gif" alt></p>
<p>这有一个明显的优点，那就是蕴涵的右边很容易计算。然而，事实证明，通过这种修改，算法不再是正确的，因为专家接受的蕴涵集对于$TH_c(\mathbb{K})$是不完整的。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229114756626.png" srcset="/img/loading.gif" class>          
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229114756626.png" srcset="/img/loading.gif" alt></p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229115036863.png" srcset="/img/loading.gif" class><img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229115222738.png" srcset="/img/loading.gif" class>          
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229115036863.png" srcset="/img/loading.gif" alt><br><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229115222738.png" srcset="/img/loading.gif" alt></p>
<h3 id="5-2-An-Exact-Exploration-by-Confidence"><a href="#5-2-An-Exact-Exploration-by-Confidence" class="headerlink" title="5.2 An Exact Exploration by Confidence"></a>5.2 An Exact Exploration by Confidence</h3><p>前面的例子表明，我们避免$TH_c(\mathbb{K})$下计算闭包的计算开销的简单想法不起作用。在这一节中，我们将展示如何通过进一步适当地修改算法来实现这一想法。为此，我们将使用算法3的较弱的推广。作为一个令人愉快的副作用，我们将得到一个适当的可信度探索算法，即新算法确实将计算$Th(P)\cap TH_c(\mathbb{K})   $的基。缺点是，由于该算法基于较弱的属性探索泛化，我们不能期望它计算最小基数的基。</p>
<p> 这种修改的主要思想如下：为我们的置信度探索设置而实例化的算法3的较弱的泛化不需要我们在$TH_c(\mathbb{K})$下计算闭包。相反，我们只需要检查给定的一组属性是否在$TH_c(\mathbb{K})$下关闭。后者的主要问题是，一般来说，我们需要考虑B⊆A的所有子集和m∈M\A的所有元素，检查它们是否满足</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229120032242.png" srcset="/img/loading.gif" class>  
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229120032242.png" srcset="/img/loading.gif" alt></p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229120328872.png" srcset="/img/loading.gif" class>       
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229120328872.png" srcset="/img/loading.gif" alt></p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229120522160.png" srcset="/img/loading.gif" class>       
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229120522160.png" srcset="/img/loading.gif" alt></p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229120730210.png" srcset="/img/loading.gif" class>       
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229120730210.png" srcset="/img/loading.gif" alt></p>
<p>基于这个结果，我们现在将调整我们的探索算法，以确保我们需要在$TH_c(\mathbb{K})$下检查封闭性的所有集合都满足等式(3)。我们可以这样做：像往常一样，我们按字典序考虑M的子集X，并且对于每个在当前已知蕴涵的集合Ki下闭合的这样的集合X，但不是$\mathbb{K}\div L_i$的内涵，我们向专家询问蕴涵</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229152230437.png" srcset="/img/loading.gif" class>       
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229152230437.png" srcset="/img/loading.gif" alt></p>
<p>此外，根据命题1，对于每个X，即$\mathbb{K}\div L_i$的意图，我们提出蕴涵</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229152551732.png" srcset="/img/loading.gif" class>       
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229152551732.png" srcset="/img/loading.gif" alt></p>
<p>生成的算法如算法5所示。不难看出，该算法确实是算法3的一个实例。因此，从定理3关于算法3的一般结果中，我们立即得到以下结果。此外，该算法仅在置信度至少为c的情况下询问蕴涵，因此算法5是一种适合于置信度探索的算法。</p>
<img src="/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229152753102.png" srcset="/img/loading.gif" class>       
<p><img src="/peerless.github.io/2020/12/28/2015-ICFCA-Exploring%20Faulty%20Data/image-20201229152753102.png" srcset="/img/loading.gif" alt></p>
<h2 id="6-Outlook-and-Further-Results"><a href="#6-Outlook-and-Further-Results" class="headerlink" title="6 Outlook and Further Results"></a>6 Outlook and Further Results</h2><p>在本文中，我们讨论了将属性探索应用于故障数据的问题。为此，我们对经典的属性探索算法进行了扩展，不仅询问数据中有效的蕴涵，而且询问那些在数据中具有高度置信度的蕴涵。这种方法背后的动机是假设只有轻微错误的数据才会使重要的蕴涵失效，而不是只有很少的反例，而不是那些确实适用于这种蕴涵的例子的数量。当然，这种方法纯粹是启发式的，应该这样对待。</p>
<p>在我们关于如何设计一个考虑到蕴涵置信度的探索算法的讨论中，</p>
<ol>
<li>我们首先形式化了专家的概念。</li>
<li>之后，我们讨论了如何将经典的属性探索看作是对一组有趣的蕴涵的探索。</li>
<li>对于这个更抽象的观点，我们讨论了对经典算法的直接概括，以及更弱的概括，它允许在选择向专家询问的含义时有更大的自由。</li>
<li>在这些推广的基础上，我们提出了一种近似算法和一种精确的置信度探索算法。</li>
</ol>
<p>这篇论文故意避免为它提出的陈述提供证据。这些证明可以在[4]中找到。在这里，我们还讨论了将目前的结果推广到一般概念包含(GCI)。GCIS是逻辑公式，它为描述逻辑领域提供了含义的概括[2]。将置信度的概念推广到地理信息系统中并不难，然后我们就可以在本文结果的基础上设计出一种算法来探索一般的概念包含，并且具有很高的置信度。这样做的直接好处是通过使用描述逻辑提高了表现力。</p>
<p>要通过置信度将探索推广到一般概念包含，必须扩展算法，使其也能够处理不断增长的属性集。更准确地说，在探索过程中，本文假定固定的属性集M可能会以一致的方式增长。置信度探索也可以适应这种设置，就像[6]使经典属性探索适应这种设置一样。</p>
<p>考虑错误数据的一个主要动机是，在实际应用中，数据从来都不是没有错误的。关于这一点，有人可能会争辩说，本文的结果有助于使属性探索在实践中更有用。然而，如果我们能够可靠地提供真实的探索用例，这种论证会更有说服力。寻找和评估这样的用例是未来研究的主要任务。</p>
<p>到目前为止还没有讨论的另一个有趣的应用程序如下。一旦专家以不等于1的置信度接受了一个蕴涵，这个蕴涵的所有反例都是错误的。我们的算法可以适用于将这些错误对象提交给专家进行纠正，从而在探索过程中提高数据集的质量。这种形式的纠错可能比遍历整个数据集并纠正所有错误更有效。这是因为根据置信度进行纠错勘探只会提出与勘探过程相关的纠错。</p>
<h2 id="词伙积累"><a href="#词伙积累" class="headerlink" title="词伙积累"></a>词伙积累</h2><ul>
<li>and vice versa：反之亦然。</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Agrawal, R., Imielinski, T., Swami, A.N.: Mining association rules between sets<br>of items in large databases. In: Proceedings of the ACM SIGMOD International<br>Conference on Management of Data, pp. 207–216 (1993)</p>
<p>[2] Baader, F., et al. (eds.): The Description Logic Handbook: Theory, Implementa-<br>tion, and Applications. Cambridge University Press, New York (2003)</p>
<p>[3] Borchmann, D.: A general form of attribute exploration. LTCS-Report 13–02.<br>Chair of Automata Theory, Institute of Theoretical Computer Science, Technische<br>Universität Dresden (2013)</p>
<p>[4] Borchmann, D.: Learning terminological knowledge with high confidence from erro-<br>neous data. Ph.D. thesis, Technische Universität Dresden (2014)</p>
<p>[5] Burmeister, P., Holzer, R.: Treating incomplete knowledge in formal concept analy-<br>sis. In: Ganter, B., Stumme, G., Wille, R. (eds.) Formal Concept Analysis. LNCS<br>(LNAI), vol. 3626, pp. 114–126. Springer, Heidelberg (2005)</p>
<p>[6] Distel, F.: Learning description logic knowledge bases from data using methods<br>from formal concept analysis. Ph.D. thesis, Technische Universität Dresden (2011)</p>
<p>[7] Ganter, B.: Attribute exploration with background knowledge. Theor. Comput.<br>Sci. 217(2), 215–233 (1999)</p>
<p>[8] Ganter, B.: Two basic algorithms in concept analysis. In: Kwuida, L., Sertkaya, B.<br>(eds.) ICFCA 2010. LNCS, vol. 5986, pp. 312–340. Springer, Heidelberg (2010)</p>
<p>[9] Ganter, B., Wille, R.: Formal Concept Analysis: Mathematical Foundations.<br>Springer, Heidelberg (1999)</p>
<p>[10] Luxenburger, M.: Implikationen, Abhängigkeiten und Galois-Abbildungen. Ph.D.<br>thesis, TH Darmstadt (1993)</p>
<p>[11] Stumme, G.: Attribute exploration with background implications and exceptions.<br>In: Bock, H.-H., Polasek, W. (eds.) Data Analysis and Information Systems: Stud-<br>ies in Classification, Data Analysis, and Knowledge Organization, pp. 457–469.<br>Springer, Heidelberg (1996)</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%BA%E6%96%87/">论文</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%BA%E6%96%87/%E5%B1%9E%E6%80%A7%E6%8E%A2%E7%B4%A2/">属性探索</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%B1%9E%E6%80%A7%E6%8E%A2%E7%B4%A2/">属性探索</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AE%B9%E9%94%99/">容错</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BD%AE%E4%BF%A1%E5%BA%A6/">置信度</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/12/10/2020-JAIHC-An%20interactive%20role%20learning%20and%C2%A0discovery%20model%20for%C2%A0multi%E2%80%91department%20%20RBAC%20building%20based%20on%C2%A0attribute%20exploration/">
                        <span class="hidden-mobile">2020-JAIHC-An interactive role learning and discovery model for multi‑department  RBAC building based on attribute exploration</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "RcI3ePX6qkbdKOX0xjPq8Xy3-gzGzoHsz",
          app_key: "suQG3XDbcx2bpMJLeuKCcqS7",
          placeholder: "由于作者水平有限，加上时间仓促，文中难免存在不足之处，敬请读者批评指正。",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "https://rci3epx6.lc-cn-n1-shared.com",
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <!--
 * @Author: your name
 * @Date: 2020-06-04 05:16:36
 * @LastEditTime: 2020-07-04 16:26:58
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \blog\themes\fluid\layout\_partial\footer.ejs
--> 
<footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://github.com/SuperficialJ/peerless.github.io." target="_blank" rel="nofollow noopener"><span>peerless</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    <!--
 * @Author: your name
 * @Date: 2020-06-28 18:23:11
 * @LastEditTime: 2020-07-04 16:28:28
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \peer-less.github.io\themes\fluid\layout\_partial\statistics.ejs
--> 

  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: inline-block">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: inline-block">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


    

    
  </div>

  <p id="hitokoto" align='center'>:D 获取中...</p>
  <script>
    fetch('https://v1.hitokoto.cn')
      .then(response => response.json())
      .then(data => {
        const hitokoto = document.getElementById('hitokoto')
        hitokoto.innerText = data.hitokoto
        })
        .catch(console.error)
  </script>

  <div align='center'>
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>
    <script>
    var now = new Date();
    function createtime(){
        var grt= new Date("06/26/2020 22:53:55");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){
            hnum = "0" + hnum;
        }
        minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if(String(mnum).length ==1 ){
                  mnum = "0" + mnum;
        }
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){
                  snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";
        document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
    }
    setInterval("createtime()",250);
    </script>
  </div>

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "2015-ICFCA-Exploring Faulty Data&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  



  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  











  

  

  

  

  

  





</body>
</html>
